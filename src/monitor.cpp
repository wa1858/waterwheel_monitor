// Program to monitor frequency of power generated by waterwheel

// TODO - Convert C functions to C++

#include <stdio.h>
#include <memory.h>
#include <time.h>
#include <string.h>
#include <windows.h>

#include <iostream>
#include <iomanip> // For setprecision
#include <array>
#include <sstream>

const static std::string WHITESPACE = "        ";

// TODO - Configure for adding version number to code
// #include "config.h"

// TODO - Confirm return result of 0 is okay
int writeData(HANDLE serial, const std::array<char, 8> &request)
{
    DWORD written, totalWritten = 0;
    if (!WriteFile(serial, request.data(), request.size(), &written, nullptr))
    {
        return 1;
    }
    return 0;
}

// TODO - What should this return if okay?
bool readData(HANDLE hSerial, std::array<char, 9> &bytesToRead)
{
    DWORD bytesRead = 0;
    bool status = ReadFile(hSerial, bytesToRead.data(), bytesToRead.size(), &bytesRead, nullptr);
    if (!status)
    {
        std::cerr << "Error - Could not read from serial port" << std::endl;
    }
    return status;
}

/**
 * Converts four char bytes to an equivalent 32-bit float
 * Implemnted as the energy meter generates data in floating
 * point format but program reads data as four distinct bytes
 */
float charToFloat(const std::array<char, 9> &bytesToRead)
{
    // Convert the four char bytes into an equivalent 32-bit float
    int byte1[4];
    byte1[0] = static_cast<int>(bytesToRead[3]);
    byte1[1] = static_cast<int>(bytesToRead[4]);
    byte1[2] = static_cast<int>(bytesToRead[5]);
    byte1[3] = static_cast<int>(bytesToRead[6]);

    // Convert the four integers into a single integer representing a 32-bit number
    unsigned intData = (byte1[0] << 24) + (byte1[1] << 16) + (byte1[2] << 8) + byte1[3];

    // Assign result to memory assigned for float, resulting in float cast
    float f;
    unsigned dw = intData;
    memcpy(&f, &dw, sizeof(float));

    return f;
}

/**
 * Create time delay as required
 */
void delay(int milli_seconds)
{
    // Storing start time
    clock_t start_time = clock();

    // Loop for required time
    while (clock() < start_time + milli_seconds)
        ;
}

/**
 * Create a HANDLE variable for accessing the serial port
 */
HANDLE setupSerial(int portNumber)
{
    // Declare variables and structures
    DCB dcbSerialParams = {0};
    COMMTIMEOUTS timeouts = {0};

    std::stringstream ss;
    ss << "\\\\.\\COM" << portNumber;
    std::string port = ss.str();

    // Open the desired serial port
    std::cout << "Opening serial port COM" << portNumber << "... ";
    HANDLE hSerial = CreateFile(
        port.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hSerial == INVALID_HANDLE_VALUE)
    {
        std::cerr << "Error" << std::endl;
        exit(EXIT_FAILURE);
    }
    std::cout << "OK" << std::endl;

    // Set device parameters (9600 baud, 1 start bit, 1 stop bit, no parity)
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);
    if (GetCommState(hSerial, &dcbSerialParams) == 0)
    {
        std::cerr << "Error getting device state" << std::endl;
        CloseHandle(hSerial);
        exit(EXIT_FAILURE);
    }

    dcbSerialParams.BaudRate = CBR_9600;
    dcbSerialParams.ByteSize = 8;
    dcbSerialParams.StopBits = ONESTOPBIT;
    dcbSerialParams.Parity = NOPARITY;
    if (SetCommState(hSerial, &dcbSerialParams) == 0)
    {
        std::cerr << "Error setting device parameters" << std::endl;
        CloseHandle(hSerial);
        exit(EXIT_FAILURE);
    }

    // Set COM port timeout settings
    timeouts.ReadIntervalTimeout = 50;
    timeouts.ReadTotalTimeoutConstant = 50;
    timeouts.ReadTotalTimeoutMultiplier = 10;
    timeouts.WriteTotalTimeoutConstant = 50;
    timeouts.WriteTotalTimeoutMultiplier = 10;
    if (SetCommTimeouts(hSerial, &timeouts) == 0)
    {
        std::cerr << "Error setting timeouts" << std::endl;
        CloseHandle(hSerial);
        exit(EXIT_FAILURE);
    }
    return hSerial;
}

int main()
{
    std::cout << "Monitor Program for Waterwheel" << std::endl;
    std::cout << "Revision 1.3" << std::endl;
    std::cout << "Build date: 26/12/2023" << std::endl;

    // TODO - Imput validation
    int port_number;
    std::cout << "Enter the desired serial port number: ";
    std::cin >> port_number;
    std::cout << "Selected port: COM" << port_number << std::endl;

    // TODO - Input validation
    float average_frequency_max, average_frequency_min;
    std::cout << "Enter the MIN frequency limit: ";
    std::cin >> average_frequency_min;
    std::cout << "Enter the MAX frequency limit: ";
    std::cin >> average_frequency_max;
    std::cout << "Limits set from " << std::fixed << std::setprecision(1)
              << average_frequency_min << "Hz to " << average_frequency_max << "Hz" << std::endl;

    // Define frequency_request command per Energy Meter Modbus ICD
    char frequency_request[8];
    frequency_request[0] = 0x01; // address 01
    frequency_request[1] = 0x04; // read input registers
    frequency_request[2] = 0x00; // Hi Byte Frequency
    frequency_request[3] = 0x46; // Lo Byte Frequency
    frequency_request[4] = 0x00; // Number of registers high
    frequency_request[5] = 0x02; // Number of registers low
    frequency_request[6] = 0x90; // Error check low - determined by sending above data using RealTerm
    frequency_request[7] = 0x1E; // Error check high - dertermined by sending above data using RealTerm

    const std::array<char, 8> req_frequency = {
        static_cast<char>(0x01),  // address 01
        static_cast<char>(0x04),  // read input registers
        static_cast<char>(0x00),  // Hi Byte Frequency
        static_cast<char>(0x46),  // Lo Byte Frequency
        static_cast<char>(0x00),  // Number of registers high
        static_cast<char>(0x02),  // Number of registers low
        static_cast<char>(0x90),  // Error check low - computed using RealTerm
        static_cast<char>(0x1E)}; // Error check high - computed using RealTerm

    std::array<char, 9> data;

    HANDLE serial = setupSerial(port_number);

    int i, j, k;
    float average_frequency, temp_sum;
    float averaging_data[10] = {0.0};

    // For use with averaging sum
    size_t num_of_values = sizeof(averaging_data) / sizeof(averaging_data[0]);

    j = 0;
    for (i = 1; i < 60000; i++)
    {
        writeData(serial, req_frequency);
        readData(serial, data);

        // Read the frequency from the Energy Meter
        float frequency = charToFloat(data);
        std::cout << "Frequency (Hz) " << frequency;

        averaging_data[j] = frequency;
        if (j == num_of_values - 1)
        {
            j = 0;
        }
        else
        {
            j++;
        }

        // Calculate the average frequency
        temp_sum = 0;
        for (k = 0; k < num_of_values; k++)
        {
            temp_sum += averaging_data[k];
        }

        average_frequency = temp_sum / num_of_values;
        std::cout << WHITESPACE << "Average Frequency (Hz) " << average_frequency;

        // Alert if average value is out of range
        if (average_frequency > average_frequency_max)
        {
            std::cout << WHITESPACE << "OVERSPEED ERROR";
            MessageBeep(MB_ICONWARNING);
        }
        else if (average_frequency < average_frequency_min)
        {
            std::cout << WHITESPACE << "UNDERSPEED ERROR";
            MessageBeep(MB_ICONWARNING);
        }
        std::cout << std::endl;

        // Delay before next printout
        delay(1200);
    }

    // Close serial port
    std::cout << "Closing serial port" << std::endl;
    if (!CloseHandle(serial))
    {
        std::cerr << "Error closing serial port" << std::endl;
        return 1;
    }
    std::cout << "Port closed" << std::endl;

    return 0;
}
