// Program to monitor frequency of power generated by waterwheel
//
// Uses COM5
//
// Prints frequency every 1.2 seconds along with a 12 second moving average
// Waterwheel rotates at approx 10rpm ie 6sec per rotation
//
// Underspeed threshold at 44Hz average and overspeed threshold at 48Hz average
//
// Source based on code and coding ideas found at following sites
//
// https://batchloaf.wordpress.com/2013/02/13/writing-bytes-to-a-serial-port-in-c/   writing data
// https://gist.github.com/uilianries/2a5ee873f1064efb192a6f4ea016a3c0   for reading data
// https://ideone.com/ridffw char to float conversion
// https://stackoverflow.com/questions/51409965/convert-char-to-float-using-union-or-memcpy char to float conversion
// https://www.geeksforgeeks.org/time-delay-c/  for time delays
//
//
//
// Program for monitoring frequency from RS PRO 1 Phase Backlit LCD Energy Meter, Type Energy Meter RS Stock No. 236-9298
// Interface via Modbus
//
//Reference: Modbus Guide (aka ICD)
//RS PRO DIN Rail Multifunction Power Meter
//MID Certified
//Stock No: 236-9298
//
//
// includes audio warning
//



// To compile with MinGW:
//
//      gcc -o <filename>.exe <filename>.c
//
//
// To run:
//
//      <filename>.exe  //.exe optional
//
 
#include <windows.h>
#include <stdio.h>
#include <memory.h>
#include <time.h>

int writedata(HANDLE hSerial1, char data_request1[8])
{
    // Function to send data request to energy meter
    DWORD bytes_written, total_bytes_written = 0;
    if(!WriteFile(hSerial1, data_request1, 8, &bytes_written, NULL))
    {
        fprintf(stderr, "Error\n");
        CloseHandle(hSerial1);
        return 1;
    } 
;
} 

BOOL readdata(HANDLE hSerial1, char bytes_to_read1[9])
{
        DWORD bytes_read1 = 0;
        BOOL status = FALSE;
        status = ReadFile(hSerial1, bytes_to_read1, 9, &bytes_read1, NULL);
        if (!status) {
            fprintf(stderr, "Error: Could not read serial port.\n");
            CloseHandle(hSerial1);
            return EXIT_FAILURE;
        }
;
}
 
float char_to_float(char bytes_to_read1[9])
	//function to convert four character bytes into the equivalent single precision floating point number. 
	//Needed because energy meter generates data in floating point format but program reads data as 4 x 8 byte characters.
{

	int byte1[4];  //start by converting the character bytes into integers
	byte1[1] = (int)bytes_to_read1[3];
	byte1[2] = (int)bytes_to_read1[4];
	byte1[3] = (int)bytes_to_read1[5];
	byte1[4] = (int)bytes_to_read1[6];
 
	int intdata;   //now convert the four integers into a single integer representing the 4 x 8 = 32bit number
	intdata = (byte1[1] * 16777216) + (byte1[2] * 65536) + (byte1[3] * 256) + byte1[4];

	float f;	//now convert the 32bit number into the single precision floating point number
	unsigned dw = intdata;
	memcpy(&f, &dw, 4);
	return f;

}



void delay_msecs(int milli_seconds)
{
    // Function for putting in a time delay in msecs

 
    // Storing start time
    clock_t start_time = clock();
 
    // looping till required time is not achieved
    while (clock() < start_time + milli_seconds)
    ;
}

 
int main()
{
    // Define frequency_request command per Energy Meter Modbus ICD
    char frequency_request[8];
    frequency_request[0] = 0x01; //address 01
    frequency_request[1] = 0x04; //read input registers
    frequency_request[2] = 0x00; //Hi Byte Frequency
    frequency_request[3] = 0x46; //Lo Byte Frequency
    frequency_request[4] = 0x00; //Number of registers high
    frequency_request[5] = 0x02; //Number of registers low
    frequency_request[6] = 0x90; //Error check low - determined by sending above data using RealTerm
    frequency_request[7] = 0x1E; //Error check high - dertermined by sending above data using RealTerm

    unsigned char bytes_to_read[9];

 
    // Declare variables and structures
    HANDLE hSerial;
    DCB dcbSerialParams = {0};
    COMMTIMEOUTS timeouts = {0};
    const float maxavfreq=48.0, minavfreq=44.0;

    // Print program header
    printf("Monitor program for waterwheel Rev 1_0    16/12/23");
    printf(" \n");
    printf(" \n");
    printf("     Minimum Frequency (Hz) %2.1f",minavfreq);
    printf(" \n");
    printf("     Maximum Frequency (Hz) %2.1f",maxavfreq);
    printf(" \n");
    printf(" \n");
    printf(" \n");

    delay_msecs(4000); //wait 4secs to allow header to be read

         
    // Open the highest available serial port number
    fprintf(stderr, "Opening serial port...");
    hSerial = CreateFile(
                "\\\\.\\COM5", GENERIC_READ|GENERIC_WRITE, 0, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if (hSerial == INVALID_HANDLE_VALUE)
    {
            fprintf(stderr, "Error\n");
            return 1;
    }
    else fprintf(stderr, "OK\n");
     
    // Set device parameters (9600 baud, 1 start bit,
    // 1 stop bit, no parity)
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);
    if (GetCommState(hSerial, &dcbSerialParams) == 0)
    {
        fprintf(stderr, "Error getting device state\n");
        CloseHandle(hSerial);
        return 1;
    }
     
    dcbSerialParams.BaudRate = CBR_9600;
    dcbSerialParams.ByteSize = 8;
    dcbSerialParams.StopBits = ONESTOPBIT;
    dcbSerialParams.Parity = NOPARITY;
    if(SetCommState(hSerial, &dcbSerialParams) == 0)
    {
        fprintf(stderr, "Error setting device parameters\n");
        CloseHandle(hSerial);
        return 1;
    }
 
    // Set COM port timeout settings
    timeouts.ReadIntervalTimeout = 50;
    timeouts.ReadTotalTimeoutConstant = 50;
    timeouts.ReadTotalTimeoutMultiplier = 10;
    timeouts.WriteTotalTimeoutConstant = 50;
    timeouts.WriteTotalTimeoutMultiplier = 10;
    if(SetCommTimeouts(hSerial, &timeouts) == 0)
    {
        fprintf(stderr, "Error setting timeouts\n");
        CloseHandle(hSerial);
        return 1;
    }
 

int i, j, k;
float average_frequency, temp_sum;
float averaging_data[10];
	averaging_data[0]=0;
	averaging_data[1]=0;
	averaging_data[2]=0;
	averaging_data[3]=0;
	averaging_data[4]=0;
	averaging_data[5]=0;
	averaging_data[6]=0;
	averaging_data[7]=0;
	averaging_data[8]=0;
	averaging_data[9]=0;

j=0;
for(i=1; i<60000; i++)
{
	writedata(hSerial,frequency_request);
	readdata(hSerial, bytes_to_read);

	float frequency; 
	frequency=char_to_float(bytes_to_read); //reads the frequency from the Energy Meter
	printf("Frequency (Hz) %2.1f",frequency);

	//now calculate the average frequency
	averaging_data[j]=frequency;
	if (j==9){j=0;}else{j++;} //incrementing the averaging data indice
	temp_sum=0;
	for(k=0; k<10; k++)
	{
		temp_sum=temp_sum+averaging_data[k];
	}

	average_frequency = temp_sum/10;
	printf("     Average Frequency (Hz) %2.1f",average_frequency);

	//now check if average frequency is out of range
	(average_frequency>maxavfreq)? printf("     OVERSPEED ERROR"): printf(" ");
	(average_frequency>maxavfreq)? MessageBeep(MB_OK): printf(" ");
	(average_frequency<minavfreq)? printf("     UNDERSPEED ERROR"): printf(" ");
	(average_frequency<minavfreq)? MessageBeep(MB_OK): printf(" ");

	printf(" \n");


	delay_msecs(1200);
}
     
    // Close serial port
    fprintf(stderr, "Closing serial port...");
    if (CloseHandle(hSerial) == 0)
    {
        fprintf(stderr, "Error\n");
        return 1;
    }
    fprintf(stderr, "OK\n");


 
 
    // exit normally
    return 0;
}

